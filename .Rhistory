sma_9 <- rollmean(adj_close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) &
(riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
View(buy)
rm(list = ls())
gc()
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(adj_close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) &
(riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
rm(list = ls())
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(adj_close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) &
(riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
rm(list = ls())
gc()
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) &
(riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
riot_df$Date[a]
buy
rm(list = ls9)
rm(list = ls())
gc9)
gc()
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
a <- 10
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
a <- 11
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
a <- 12
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
buy
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
for (a in 10:length(open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
a
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
buy <- character()
for (a in 10:length(riot_df$Open)) {
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
if ((riot_df$Open[a] > gap_up) & (riot_df$Open[a] > sma_9[a - 8])) {
print("buy")
buy <- append(buy, riot_df$Date[a])
}
}
buy <- data.frame(date_buy = buy,
stringsAsFactors = F)
View(buy)
dim(buy)
library(zoo)
riot_df <- read.csv("RIOT.csv",
header = TRUE,
stringsAsFactors = F)
sma_9 <- rollmean(riot_df$Adj.Close, 9)
length(riot_df$Adj.Close) - length(sma_9)
buy <- character()
riot_df$Adj.Close[a - 1]
gap_up <- riot_df$Adj.Close[a - 1] * 1.05
gap_up
View(riot_df)
rm(list = ls())
q()
setwd("~/Work/___DataKolektiv/Projects/WikimediaDEU/_WMDE_Projects/WDCM_Dev/WDCM_Dashboards/WDCM_SemanticsDashboard/WDCM-Semantics-Dashboard")
### --------------------------------
### --- general
library(shiny)
library(shinydashboard)
library(data.table)
library(DT)
library(stringr)
library(tidyr)
library(dplyr)
library(reshape2)
library(XML)
### --- compute
library(parallelDist)
### --- visualization
library(visNetwork)
library(RColorBrewer)
library(networkD3)
library(ggplot2)
library(ggrepel)
library(scales)
library(rbokeh)
### --- connect
library(httr)
library(curl)
### --- Config File
params <- xmlParse('wdcmConfig_wdcmSemanticsDashboard.xml')
params <- xmlToList(params)
### --- functions
get_WDCM_table <- function(url_dir, filename, row_names = F) {
if (row_names == T) {
read.csv(URLencode(paste0(url_dir, filename)),
header = T,
stringsAsFactors = F,
check.names = F,
row.names = 1)
} else {
read.csv(URLencode(paste0(url_dir, filename)),
header = T,
stringsAsFactors = F,
check.names = F)
}
}
# - projectType() to determine project type
projectType <- function(projectName) {
unname(sapply(projectName, function(x) {
if (grepl("commons", x, fixed = T)) {"Commons"
} else if (grepl("mediawiki|meta|species|wikidata", x)) {"Other"
} else if (grepl("wiki$", x)) {"Wikipedia"
} else if (grepl("quote$", x)) {"Wikiquote"
} else if (grepl("voyage$", x)) {"Wikivoyage"
} else if (grepl("news$", x)) {"Wikinews"
} else if (grepl("source$", x)) {"Wikisource"
} else if (grepl("wiktionary$", x)) {"Wiktionary"
} else if (grepl("versity$", x)) {"Wikiversity"
} else if (grepl("books$", x)) {"Wikibooks"
} else {"Other"}
}))
}
url <- params$remoteMLDir
page <- as.character(GET(url), config = httr::config(http_version = 2))
links <- str_extract_all(page, "<a href=.+>.+</a>")
links <- sapply(links, function(x) {str_extract_all(x, ">.+<")})
links <- sapply(links, function(x) {gsub('^>|"|<$|>|<', "", x)})
links <- links[3:length(links)]
tSNEmapsFiles <- links[which(grepl("wdcm2_tsne2D_project_", links, fixed = T))]
itemTopicTables <- links[which(grepl("wdcm2_itemtopic_", links, fixed = T))]
projectTopicTables <- links[which(grepl("wdcm2_projecttopic_", links, fixed = T))]
wdcmProject <- get_WDCM_table(params$remoteETLDir, 'wdcm_project.csv')
wdcmProject$type <- projectType(wdcmProject$eu_project)
colnames(wdcmProject) <- c('Project', 'Usage', 'Project Type')
wdcm_category_item <- get_WDCM_table(
params$remoteETLDir, 'wdcm_category_item.csv', row_names = T)
colnames(wdcm_category_item) <- c('Entity', 'Label', 'Usage', 'Category')
wdcmProjectCategory <- get_WDCM_table(params$remoteETLDir, 'wdcm_project_category.csv', row_names = F)
wdcmProjectCategory$type <- projectType(wdcmProjectCategory$eu_project)
colnames(wdcmProjectCategory) <- c('Project', 'Category', 'Usage', 'Project Type')
# - fix `Wikimedia_Internal` to `Wikimedia`
wdcmProjectCategory$Category[wdcmProjectCategory$Category == 'Wikimedia_Internal'] <-
'Wikimedia'
wdcmCategory <- get_WDCM_table(params$remoteETLDir, 'wdcm_category.csv', row_names = T)
colnames(wdcmCategory) <- c('Category', 'Usage')
# - fix `Wikimedia_Internal` to `Wikimedia`
wdcmCategory$Category[wdcmCategory$Category == 'Wikimedia_Internal'] <-
'Wikimedia'
wdcm2_projects_2dmaps <- lapply(tSNEmapsFiles, function(x) {
get_WDCM_table(params$remoteMLDir, x, row_names = F)
})
# - enter category info:
for (i in 1:length(tSNEmapsFiles)) {
wdcm2_projects_2dmaps[[i]]$Category <- gsub(".csv", "",
strsplit(tSNEmapsFiles[i], "_")[[1]][4], fixed = T)
}
wdcm2_projects_2dmaps <- rbindlist(wdcm2_projects_2dmaps)
wdcm2_projects_2dmaps$V1 <- NULL
colnames(wdcm2_projects_2dmaps) <- c('D1', 'D2', 'Project', 'Project Type', 'Category')
wdcm2_projects_2dmaps$Category[wdcm2_projects_2dmaps$Category == "Wikimedia_Internal"] <-
'Wikimedia'
projectTopic <- lapply(projectTopicTables, function(x) {
d <- get_WDCM_table(url_dir = params$remoteMLDir, x, row_names = T)
colnames(d)[1] <- 'id'
d
})
names(projectTopic) <- sapply(projectTopicTables, function(x) {
strsplit(strsplit(x, split = ".", fixed = T)[[1]][1],
split = "_",
fixed = T)[[1]][3]
})
update <- read.csv(params$update_File_Path,
header = T,
check.names = F,
stringsAsFactors = F,
row.names = 1)
### - Determine Constants
# - determine Projects
projects <- wdcmProject$Project
# - determine present Project Types
projectTypes <- unique(wdcmProject$`Project Type`)
# - and assign Brewer colors
lengthProjectColor <- length(unique(wdcmProject$`Project Type`))
projectTypeColor <- brewer.pal(lengthProjectColor, "Set1")
names(projectTypeColor) <- unique(wdcmProject$`Project Type`)
# - determine Categories
categories <- wdcmCategory$Category
# - totalUsage
totalUsage <- sum(wdcmProject$Usage)
totalProjects <- length(wdcmProject$Project)
totalCategories <- length(wdcmCategory$Category)
totalProjectTypes <- length(unique(wdcmProject$`Project Type`))
### --- prepare search constants for Tabs/Crosstabs
search_projectTypes <- paste("_", projectTypes, sep = "")
unzip_projectTypes <- lapply(projectTypes, function(x) {
wdcmProject$Project[which(wdcmProject$`Project Type` %in% x)]
})
names(unzip_projectTypes) <- search_projectTypes
itemTopicTables
dFile <- itemTopicTables[1]
dFile
iT <- get_WDCM_table(url_dir = params$remoteMLDir, dFile, row_names = F)
View(iT)
View(iT)
iT[, 1] <- NULL
runApp()
cTopic <- 1
iT
w <- which(colnames(iT) == cTopic)
w
cTopic
colnames(iT)
w <- which(colnames(iT) == cTopic)
runApp()
cTopic <- "Topic 1"
w <- which(colnames(iT) == cTopic)
w
colnames(iT)
cTopic <- "topic1"
w <- which(colnames(iT) == cTopic)
w
itemNames <- iT[, c(1, w)]
itemNames
itemNames <- itemNames[order(-itemNames[, 2]), ]
itemNames <- itemNames$Entity
itemNames
colnames(iT)[1] <- "Entity"
itemNames
itemNames <- itemNames[order(-itemNames[, 2]), ]
itemNames <- iT[, c(1, w)]
itemNames
itemNames <- itemNames[order(-itemNames[, 2]), ]
itemNames <- itemNames$Entity
itemNames
root <- dplyr::select(itemTopic(), starts_with('topic'))
root <- dplyr::select(iT, starts_with('topic'))
root
selItems <- wdcm_category_item %>%
filter(grepl('Architectural Structure', wdcm_category_item$Category)) %>%
arrange(desc(Usage)) %>%
head(50) %>%
select(Entity, Label)
selItems
w <- which(itemNames %in% selItems$Entity)
w
colnames(iT)
head(iT$Entity)
cTopic
w <- which(colnames(iT) == cTopic)
w
itemNames <- iT[, c(1, w)]
itemNames
View(itemNames)
itemNames <- itemNames[order(-itemNames[, 2]), ]
itemNames <- itemNames$Entity
root <- dplyr::select(iT, starts_with('topic'))
root
class(root)
categories
wdcm_category_item$Category
selItems <- wdcm_category_item %>%
filter(grepl("Architectural Structure", wdcm_category_item$Category)) %>%
arrange(desc(Usage)) %>%
head(50) %>%
select(Entity, Label)
selItems
itemNames
selItems$Entity
View(wdcm_category_item)
runApp()
rm(list = ls())
rm(list = ls())
url <- params$remoteMLDir
### --- Config File
params <- xmlParse('wdcmConfig_wdcmSemanticsDashboard.xml')
params <- xmlToList(params)
### --- functions
get_WDCM_table <- function(url_dir, filename, row_names = F) {
if (row_names == T) {
read.csv(URLencode(paste0(url_dir, filename)),
header = T,
stringsAsFactors = F,
check.names = F,
row.names = 1)
} else {
read.csv(URLencode(paste0(url_dir, filename)),
header = T,
stringsAsFactors = F,
check.names = F)
}
}
# - projectType() to determine project type
projectType <- function(projectName) {
unname(sapply(projectName, function(x) {
if (grepl("commons", x, fixed = T)) {"Commons"
} else if (grepl("mediawiki|meta|species|wikidata", x)) {"Other"
} else if (grepl("wiki$", x)) {"Wikipedia"
} else if (grepl("quote$", x)) {"Wikiquote"
} else if (grepl("voyage$", x)) {"Wikivoyage"
} else if (grepl("news$", x)) {"Wikinews"
} else if (grepl("source$", x)) {"Wikisource"
} else if (grepl("wiktionary$", x)) {"Wiktionary"
} else if (grepl("versity$", x)) {"Wikiversity"
} else if (grepl("books$", x)) {"Wikibooks"
} else {"Other"}
}))
}
url <- params$remoteMLDir
page <- as.character(GET(url), config = httr::config(http_version = 2))
links <- str_extract_all(page, "<a href=.+>.+</a>")
links <- sapply(links, function(x) {str_extract_all(x, ">.+<")})
links <- sapply(links, function(x) {gsub('^>|"|<$|>|<', "", x)})
links <- links[3:length(links)]
links
tSNEmapsFiles <- links[which(grepl("wdcm2_tsne2D_project_", links, fixed = T))]
itemTopicTables <- links[which(grepl("wdcm2_itemtopic_", links, fixed = T))]
projectTopicTables <- links[which(grepl("wdcm2_projecttopic_", links, fixed = T))]
wdcmProject <- get_WDCM_table(params$remoteETLDir, 'wdcm_project.csv')
wdcmProject$type <- projectType(wdcmProject$eu_project)
colnames(wdcmProject) <- c('Project', 'Usage', 'Project Type')
wdcm_category_item <- get_WDCM_table(
params$remoteETLDir, 'wdcm_category_item.csv', row_names = T)
colnames(wdcm_category_item) <- c('Entity', 'Label', 'Usage', 'Category')
wdcmProjectCategory <- get_WDCM_table(params$remoteETLDir, 'wdcm_project_category.csv', row_names = F)
wdcmProjectCategory$type <- projectType(wdcmProjectCategory$eu_project)
colnames(wdcmProjectCategory) <- c('Project', 'Category', 'Usage', 'Project Type')
# - fix `Wikimedia_Internal` to `Wikimedia`
wdcmProjectCategory$Category[wdcmProjectCategory$Category == 'Wikimedia_Internal'] <-
'Wikimedia'
wdcmCategory <- get_WDCM_table(params$remoteETLDir, 'wdcm_category.csv', row_names = T)
colnames(wdcmCategory) <- c('Category', 'Usage')
# - fix `Wikimedia_Internal` to `Wikimedia`
wdcmCategory$Category[wdcmCategory$Category == 'Wikimedia_Internal'] <-
'Wikimedia'
wdcm2_projects_2dmaps <- lapply(tSNEmapsFiles, function(x) {
get_WDCM_table(params$remoteMLDir, x, row_names = F)
})
# - enter category info:
for (i in 1:length(tSNEmapsFiles)) {
wdcm2_projects_2dmaps[[i]]$Category <- gsub(".csv", "",
strsplit(tSNEmapsFiles[i], "_")[[1]][4], fixed = T)
}
wdcm2_projects_2dmaps <- rbindlist(wdcm2_projects_2dmaps)
wdcm2_projects_2dmaps$V1 <- NULL
colnames(wdcm2_projects_2dmaps) <- c('D1', 'D2', 'Project', 'Project Type', 'Category')
wdcm2_projects_2dmaps$Category[wdcm2_projects_2dmaps$Category == "Wikimedia_Internal"] <-
'Wikimedia'
projectTopic <- lapply(projectTopicTables, function(x) {
d <- get_WDCM_table(url_dir = params$remoteMLDir, x, row_names = T)
colnames(d)[1] <- 'id'
d
})
names(projectTopic) <- sapply(projectTopicTables, function(x) {
strsplit(strsplit(x, split = ".", fixed = T)[[1]][1],
split = "_",
fixed = T)[[1]][3]
})
update <- read.csv(params$update_File_Path,
header = T,
check.names = F,
stringsAsFactors = F,
row.names = 1)
### - Determine Constants
# - determine Projects
projects <- wdcmProject$Project
# - determine present Project Types
projectTypes <- unique(wdcmProject$`Project Type`)
# - and assign Brewer colors
lengthProjectColor <- length(unique(wdcmProject$`Project Type`))
projectTypeColor <- brewer.pal(lengthProjectColor, "Set1")
names(projectTypeColor) <- unique(wdcmProject$`Project Type`)
# - determine Categories
categories <- wdcmCategory$Category
# - totalUsage
totalUsage <- sum(wdcmProject$Usage)
totalProjects <- length(wdcmProject$Project)
totalCategories <- length(wdcmCategory$Category)
totalProjectTypes <- length(unique(wdcmProject$`Project Type`))
### --- prepare search constants for Tabs/Crosstabs
search_projectTypes <- paste("_", projectTypes, sep = "")
categories
wOther <- which(categories == "Other")
wOther
runApp()
# Set options here
options(golem.app.prod = FALSE)
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
shiny::runApp()
# Set options here
options(golem.app.prod = FALSE)
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
## Dependencies ----
## Add one line by package you want to add as dependency
usethis::use_package( "thinkr" )
